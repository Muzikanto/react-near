// Code is generated by react-near

import { useNearQuery, useNearMutation, useNearEnv, NearEnvironment } from "react-near";
import { NearQueryOptions } from "react-near/hooks/query";
import { NearMutationOptions } from "react-near/hooks/mutation";

export const GAME_CONTRACT_NAME_MAINNET = 'mfight.near';
export const GAME_CONTRACT_NAME_TESTNET = 'dev-1670177534740-91620037641534';

export enum GameViewMethods {
  ft_balance_of = 'ft_balance_of',
  ft_metadata = 'ft_metadata',
  ft_total_supply = 'ft_total_supply',
  game_npc = 'game_npc',
  game_player = 'game_player',
  game_player_npc_count = 'game_player_npc_count',
  game_player_npc_list = 'game_player_npc_list',
  game_player_room_count = 'game_player_room_count',
  game_player_room_list = 'game_player_room_list',
  game_room = 'game_room',
  game_upgrade_room_price = 'game_upgrade_room_price',
  is_paused = 'is_paused',
  nft_is_approved = 'nft_is_approved',
  nft_metadata = 'nft_metadata',
  nft_payout = 'nft_payout',
  nft_supply_for_owner = 'nft_supply_for_owner',
  nft_token = 'nft_token',
  nft_tokens = 'nft_tokens',
  nft_tokens_for_owner = 'nft_tokens_for_owner',
  nft_total_supply = 'nft_total_supply',
  storage_balance_bounds = 'storage_balance_bounds',
  storage_balance_of = 'storage_balance_of',
}

export enum GameChangeMethods {
  ft_resolve_transfer = 'ft_resolve_transfer',
  ft_transfer = 'ft_transfer', // payable
  ft_transfer_call = 'ft_transfer_call', // payable
  game_npc_move = 'game_npc_move',
  game_process = 'game_process',
  game_register = 'game_register', // payable
  game_room_claim = 'game_room_claim',
  game_upgrade_room = 'game_upgrade_room',
  market_buy_npc = 'market_buy_npc', // payable
  market_buy_room = 'market_buy_room', // payable
  new_default_meta = 'new_default_meta',
  nft_approve = 'nft_approve', // payable
  nft_resolve_transfer = 'nft_resolve_transfer',
  nft_revoke = 'nft_revoke', // payable
  nft_revoke_all = 'nft_revoke_all', // payable
  nft_transfer = 'nft_transfer', // payable
  nft_transfer_call = 'nft_transfer_call', // payable
  nft_transfer_payout = 'nft_transfer_payout', // payable
  set_is_paused = 'set_is_paused',
  storage_deposit = 'storage_deposit', // payable
  storage_unregister = 'storage_unregister', // payable
  storage_withdraw = 'storage_withdraw', // payable
}

export interface IGameContract {
   // view methods
   ft_balance_of(args: IFtBalanceOfArgs): IFtBalanceOfResult
   ft_metadata(args: IFtMetadataArgs): IFtMetadataResult
   ft_total_supply(args: IFtTotalSupplyArgs): IFtTotalSupplyResult
   game_npc(args: IGameNpcArgs): IGameNpcResult
   game_player(args: IGamePlayerArgs): IGamePlayerResult
   game_player_npc_count(args: IGamePlayerNpcCountArgs): IGamePlayerNpcCountResult
   game_player_npc_list(args: IGamePlayerNpcListArgs): IGamePlayerNpcListResult
   game_player_room_count(args: IGamePlayerRoomCountArgs): IGamePlayerRoomCountResult
   game_player_room_list(args: IGamePlayerRoomListArgs): IGamePlayerRoomListResult
   game_room(args: IGameRoomArgs): IGameRoomResult
   game_upgrade_room_price(args: IGameUpgradeRoomPriceArgs): IGameUpgradeRoomPriceResult
   is_paused(args: IIsPausedArgs): IIsPausedResult
   nft_is_approved(args: INftIsApprovedArgs): INftIsApprovedResult
   nft_metadata(args: INftMetadataArgs): INftMetadataResult
   nft_payout(args: INftPayoutArgs): INftPayoutResult
   nft_supply_for_owner(args: INftSupplyForOwnerArgs): INftSupplyForOwnerResult
   nft_token(args: INftTokenArgs): INftTokenResult
   nft_tokens(args: INftTokensArgs): INftTokensResult
   nft_tokens_for_owner(args: INftTokensForOwnerArgs): INftTokensForOwnerResult
   nft_total_supply(args: INftTotalSupplyArgs): INftTotalSupplyResult
   storage_balance_bounds(args: IStorageBalanceBoundsArgs): IStorageBalanceBoundsResult
   storage_balance_of(args: IStorageBalanceOfArgs): IStorageBalanceOfResult
   // change methods
   ft_resolve_transfer(args: IFtResolveTransferArgs): IFtResolveTransferResult
   ft_transfer(args: IFtTransferArgs): IFtTransferResult
   ft_transfer_call(args: IFtTransferCallArgs): IFtTransferCallResult
   game_npc_move(args: IGameNpcMoveArgs): IGameNpcMoveResult
   game_process(args: IGameProcessArgs): IGameProcessResult
   game_register(args: IGameRegisterArgs): IGameRegisterResult
   game_room_claim(args: IGameRoomClaimArgs): IGameRoomClaimResult
   game_upgrade_room(args: IGameUpgradeRoomArgs): IGameUpgradeRoomResult
   market_buy_npc(args: IMarketBuyNpcArgs): IMarketBuyNpcResult
   market_buy_room(args: IMarketBuyRoomArgs): IMarketBuyRoomResult
   new_default_meta(args: INewDefaultMetaArgs): INewDefaultMetaResult
   nft_approve(args: INftApproveArgs): INftApproveResult
   nft_resolve_transfer(args: INftResolveTransferArgs): INftResolveTransferResult
   nft_revoke(args: INftRevokeArgs): INftRevokeResult
   nft_revoke_all(args: INftRevokeAllArgs): INftRevokeAllResult
   nft_transfer(args: INftTransferArgs): INftTransferResult
   nft_transfer_call(args: INftTransferCallArgs): INftTransferCallResult
   nft_transfer_payout(args: INftTransferPayoutArgs): INftTransferPayoutResult
   set_is_paused(args: ISetIsPausedArgs): ISetIsPausedResult
   storage_deposit(args: IStorageDepositArgs): IStorageDepositResult
   storage_unregister(args: IStorageUnregisterArgs): IStorageUnregisterResult
   storage_withdraw(args: IStorageWithdrawArgs): IStorageWithdrawResult
}

export function useGameContractId() {
  const nearEnv = useNearEnv();

  return nearEnv.value === NearEnvironment.MainNet ? GAME_CONTRACT_NAME_MAINNET : GAME_CONTRACT_NAME_TESTNET;
}


export function useGameQueryRaw<Res = any, Req extends { [key: string]: any } = any>(
  methodName: GameViewMethods,
  opts: Omit<NearQueryOptions<Res, Req>, 'contract'> = {}
) {
  const contract = useGameContractId();
  return useNearQuery(methodName, { contract, ...opts });
}
export function useGameMutationRaw<Res = any, Req extends { [key: string]: any } = any>(
  methodName: GameChangeMethods,
  opts: Omit<NearMutationOptions<Res, Req>, 'contract'> = {}
) {
  const contract = useGameContractId();
  return useNearMutation(methodName, { contract, ...opts });
}

// ft_balance_of query

export type IFtBalanceOfArgs = {
   account_id: AccountId;
};

export type IFtBalanceOfResult = U128;

export function useFtBalanceOfQuery(opts: Omit<NearQueryOptions<IFtBalanceOfResult, IFtBalanceOfArgs>, 'contract'>) {
    return useGameQueryRaw<IFtBalanceOfResult, IFtBalanceOfArgs>(GameViewMethods.ft_balance_of, opts);
}

// ft_metadata query

export type IFtMetadataArgs = {

};

export type IFtMetadataResult = FungibleTokenMetadata;

export function useFtMetadataQuery(opts: Omit<NearQueryOptions<IFtMetadataResult, IFtMetadataArgs>, 'contract'>) {
    return useGameQueryRaw<IFtMetadataResult, IFtMetadataArgs>(GameViewMethods.ft_metadata, opts);
}

// ft_resolve_transfer mutation

export type IFtResolveTransferArgs = {
   sender_id: AccountId;
   receiver_id: AccountId;
   amount: U128;
};

export type IFtResolveTransferResult = U128;

export function useFtResolveTransferMutation(opts: Omit<NearMutationOptions<IFtResolveTransferResult, IFtResolveTransferArgs>, 'contract'>) {
    return useGameMutationRaw<IFtResolveTransferResult, IFtResolveTransferArgs>(GameChangeMethods.ft_resolve_transfer, opts);
}

// ft_total_supply query

export type IFtTotalSupplyArgs = {

};

export type IFtTotalSupplyResult = U128;

export function useFtTotalSupplyQuery(opts: Omit<NearQueryOptions<IFtTotalSupplyResult, IFtTotalSupplyArgs>, 'contract'>) {
    return useGameQueryRaw<IFtTotalSupplyResult, IFtTotalSupplyArgs>(GameViewMethods.ft_total_supply, opts);
}

// ft_transfer mutation (payable)

export type IFtTransferArgs = {
   receiver_id: AccountId;
   amount: U128;
   memo: string | null;
};

export type IFtTransferResult = void;

export function useFtTransferMutation(opts: Omit<NearMutationOptions<IFtTransferResult, IFtTransferArgs>, 'contract'>) {
    return useGameMutationRaw<IFtTransferResult, IFtTransferArgs>(GameChangeMethods.ft_transfer, opts);
}

// ft_transfer_call mutation (payable)

export type IFtTransferCallArgs = {
   receiver_id: AccountId;
   amount: U128;
   memo: string | null;
   msg: string;
};

export type IFtTransferCallResult = PromiseOrValueU128;

export function useFtTransferCallMutation(opts: Omit<NearMutationOptions<IFtTransferCallResult, IFtTransferCallArgs>, 'contract'>) {
    return useGameMutationRaw<IFtTransferCallResult, IFtTransferCallArgs>(GameChangeMethods.ft_transfer_call, opts);
}

// game_npc query

export type IGameNpcArgs = {
   npc_id: string;
};

export type IGameNpcResult = JsonNpc | null;

export function useGameNpcQuery(opts: Omit<NearQueryOptions<IGameNpcResult, IGameNpcArgs>, 'contract'>) {
    return useGameQueryRaw<IGameNpcResult, IGameNpcArgs>(GameViewMethods.game_npc, opts);
}

// game_npc_move mutation

export type IGameNpcMoveArgs = {
   npc_id: string;
   to_room_id: string;
};

export type IGameNpcMoveResult = void;

export function useGameNpcMoveMutation(opts: Omit<NearMutationOptions<IGameNpcMoveResult, IGameNpcMoveArgs>, 'contract'>) {
    return useGameMutationRaw<IGameNpcMoveResult, IGameNpcMoveArgs>(GameChangeMethods.game_npc_move, opts);
}

// game_player query

export type IGamePlayerArgs = {
   account_id: AccountId;
};

export type IGamePlayerResult = Player | null;

export function useGamePlayerQuery(opts: Omit<NearQueryOptions<IGamePlayerResult, IGamePlayerArgs>, 'contract'>) {
    return useGameQueryRaw<IGamePlayerResult, IGamePlayerArgs>(GameViewMethods.game_player, opts);
}

// game_player_npc_count query

export type IGamePlayerNpcCountArgs = {
   account_id: AccountId;
};

export type IGamePlayerNpcCountResult = integer;

export function useGamePlayerNpcCountQuery(opts: Omit<NearQueryOptions<IGamePlayerNpcCountResult, IGamePlayerNpcCountArgs>, 'contract'>) {
    return useGameQueryRaw<IGamePlayerNpcCountResult, IGamePlayerNpcCountArgs>(GameViewMethods.game_player_npc_count, opts);
}

// game_player_npc_list query

export type IGamePlayerNpcListArgs = {
   account_id: AccountId;
};

export type IGamePlayerNpcListResult = JsonNpc[];

export function useGamePlayerNpcListQuery(opts: Omit<NearQueryOptions<IGamePlayerNpcListResult, IGamePlayerNpcListArgs>, 'contract'>) {
    return useGameQueryRaw<IGamePlayerNpcListResult, IGamePlayerNpcListArgs>(GameViewMethods.game_player_npc_list, opts);
}

// game_player_room_count query

export type IGamePlayerRoomCountArgs = {
   account_id: AccountId;
};

export type IGamePlayerRoomCountResult = integer;

export function useGamePlayerRoomCountQuery(opts: Omit<NearQueryOptions<IGamePlayerRoomCountResult, IGamePlayerRoomCountArgs>, 'contract'>) {
    return useGameQueryRaw<IGamePlayerRoomCountResult, IGamePlayerRoomCountArgs>(GameViewMethods.game_player_room_count, opts);
}

// game_player_room_list query

export type IGamePlayerRoomListArgs = {
   account_id: AccountId;
};

export type IGamePlayerRoomListResult = JsonRoom[];

export function useGamePlayerRoomListQuery(opts: Omit<NearQueryOptions<IGamePlayerRoomListResult, IGamePlayerRoomListArgs>, 'contract'>) {
    return useGameQueryRaw<IGamePlayerRoomListResult, IGamePlayerRoomListArgs>(GameViewMethods.game_player_room_list, opts);
}

// game_process mutation

export type IGameProcessArgs = {

};

export type IGameProcessResult = boolean;

export function useGameProcessMutation(opts: Omit<NearMutationOptions<IGameProcessResult, IGameProcessArgs>, 'contract'>) {
    return useGameMutationRaw<IGameProcessResult, IGameProcessArgs>(GameChangeMethods.game_process, opts);
}

// game_register mutation (payable)

export type IGameRegisterArgs = {

};

export type IGameRegisterResult = Player;

export function useGameRegisterMutation(opts: Omit<NearMutationOptions<IGameRegisterResult, IGameRegisterArgs>, 'contract'>) {
    return useGameMutationRaw<IGameRegisterResult, IGameRegisterArgs>(GameChangeMethods.game_register, opts);
}

// game_room query

export type IGameRoomArgs = {
   room_id: string;
};

export type IGameRoomResult = JsonRoom | null;

export function useGameRoomQuery(opts: Omit<NearQueryOptions<IGameRoomResult, IGameRoomArgs>, 'contract'>) {
    return useGameQueryRaw<IGameRoomResult, IGameRoomArgs>(GameViewMethods.game_room, opts);
}

// game_room_claim mutation

export type IGameRoomClaimArgs = {
   room_id: string;
};

export type IGameRoomClaimResult = boolean;

export function useGameRoomClaimMutation(opts: Omit<NearMutationOptions<IGameRoomClaimResult, IGameRoomClaimArgs>, 'contract'>) {
    return useGameMutationRaw<IGameRoomClaimResult, IGameRoomClaimArgs>(GameChangeMethods.game_room_claim, opts);
}

// game_upgrade_room mutation

export type IGameUpgradeRoomArgs = {
   room_id: string;
};

export type IGameUpgradeRoomResult = JsonRoom;

export function useGameUpgradeRoomMutation(opts: Omit<NearMutationOptions<IGameUpgradeRoomResult, IGameUpgradeRoomArgs>, 'contract'>) {
    return useGameMutationRaw<IGameUpgradeRoomResult, IGameUpgradeRoomArgs>(GameChangeMethods.game_upgrade_room, opts);
}

// game_upgrade_room_price query

export type IGameUpgradeRoomPriceArgs = {
   room_id: string;
};

export type IGameUpgradeRoomPriceResult = U128 | null;

export function useGameUpgradeRoomPriceQuery(opts: Omit<NearQueryOptions<IGameUpgradeRoomPriceResult, IGameUpgradeRoomPriceArgs>, 'contract'>) {
    return useGameQueryRaw<IGameUpgradeRoomPriceResult, IGameUpgradeRoomPriceArgs>(GameViewMethods.game_upgrade_room_price, opts);
}

// is_paused query

export type IIsPausedArgs = {

};

export type IIsPausedResult = boolean;

export function useIsPausedQuery(opts: Omit<NearQueryOptions<IIsPausedResult, IIsPausedArgs>, 'contract'>) {
    return useGameQueryRaw<IIsPausedResult, IIsPausedArgs>(GameViewMethods.is_paused, opts);
}

// market_buy_npc mutation (payable)

export type IMarketBuyNpcArgs = {

};

export type IMarketBuyNpcResult = JsonNpc;

export function useMarketBuyNpcMutation(opts: Omit<NearMutationOptions<IMarketBuyNpcResult, IMarketBuyNpcArgs>, 'contract'>) {
    return useGameMutationRaw<IMarketBuyNpcResult, IMarketBuyNpcArgs>(GameChangeMethods.market_buy_npc, opts);
}

// market_buy_room mutation (payable)

export type IMarketBuyRoomArgs = {
   room_type: RoomType;
};

export type IMarketBuyRoomResult = JsonRoom;

export function useMarketBuyRoomMutation(opts: Omit<NearMutationOptions<IMarketBuyRoomResult, IMarketBuyRoomArgs>, 'contract'>) {
    return useGameMutationRaw<IMarketBuyRoomResult, IMarketBuyRoomArgs>(GameChangeMethods.market_buy_room, opts);
}

// new_default_meta mutation

export type INewDefaultMetaArgs = {
   owner_id: AccountId;
};

export type INewDefaultMetaResult = void;

export function useNewDefaultMetaMutation(opts: Omit<NearMutationOptions<INewDefaultMetaResult, INewDefaultMetaArgs>, 'contract'>) {
    return useGameMutationRaw<INewDefaultMetaResult, INewDefaultMetaArgs>(GameChangeMethods.new_default_meta, opts);
}

// nft_approve mutation (payable)

export type INftApproveArgs = {
   token_id: string;
   account_id: AccountId;
   msg: string | null;
};

export type INftApproveResult = void | null;

export function useNftApproveMutation(opts: Omit<NearMutationOptions<INftApproveResult, INftApproveArgs>, 'contract'>) {
    return useGameMutationRaw<INftApproveResult, INftApproveArgs>(GameChangeMethods.nft_approve, opts);
}

// nft_is_approved query

export type INftIsApprovedArgs = {
   token_id: string;
   approved_account_id: AccountId;
   approval_id: integer | null;
};

export type INftIsApprovedResult = boolean;

export function useNftIsApprovedQuery(opts: Omit<NearQueryOptions<INftIsApprovedResult, INftIsApprovedArgs>, 'contract'>) {
    return useGameQueryRaw<INftIsApprovedResult, INftIsApprovedArgs>(GameViewMethods.nft_is_approved, opts);
}

// nft_metadata query

export type INftMetadataArgs = {

};

export type INftMetadataResult = NFTContractMetadata;

export function useNftMetadataQuery(opts: Omit<NearQueryOptions<INftMetadataResult, INftMetadataArgs>, 'contract'>) {
    return useGameQueryRaw<INftMetadataResult, INftMetadataArgs>(GameViewMethods.nft_metadata, opts);
}

// nft_payout query

export type INftPayoutArgs = {
   token_id: string;
   balance: U128;
   max_len_payout: integer;
};

export type INftPayoutResult = Payout;

export function useNftPayoutQuery(opts: Omit<NearQueryOptions<INftPayoutResult, INftPayoutArgs>, 'contract'>) {
    return useGameQueryRaw<INftPayoutResult, INftPayoutArgs>(GameViewMethods.nft_payout, opts);
}

// nft_resolve_transfer mutation

export type INftResolveTransferArgs = {
   previous_owner_id: AccountId;
   receiver_id: AccountId;
   token_id: string;
   approved_account_ids: object | null;
};

export type INftResolveTransferResult = boolean;

export function useNftResolveTransferMutation(opts: Omit<NearMutationOptions<INftResolveTransferResult, INftResolveTransferArgs>, 'contract'>) {
    return useGameMutationRaw<INftResolveTransferResult, INftResolveTransferArgs>(GameChangeMethods.nft_resolve_transfer, opts);
}

// nft_revoke mutation (payable)

export type INftRevokeArgs = {
   token_id: string;
   account_id: AccountId;
};

export type INftRevokeResult = void;

export function useNftRevokeMutation(opts: Omit<NearMutationOptions<INftRevokeResult, INftRevokeArgs>, 'contract'>) {
    return useGameMutationRaw<INftRevokeResult, INftRevokeArgs>(GameChangeMethods.nft_revoke, opts);
}

// nft_revoke_all mutation (payable)

export type INftRevokeAllArgs = {
   token_id: string;
};

export type INftRevokeAllResult = void;

export function useNftRevokeAllMutation(opts: Omit<NearMutationOptions<INftRevokeAllResult, INftRevokeAllArgs>, 'contract'>) {
    return useGameMutationRaw<INftRevokeAllResult, INftRevokeAllArgs>(GameChangeMethods.nft_revoke_all, opts);
}

// nft_supply_for_owner query

export type INftSupplyForOwnerArgs = {
   account_id: AccountId;
};

export type INftSupplyForOwnerResult = U128;

export function useNftSupplyForOwnerQuery(opts: Omit<NearQueryOptions<INftSupplyForOwnerResult, INftSupplyForOwnerArgs>, 'contract'>) {
    return useGameQueryRaw<INftSupplyForOwnerResult, INftSupplyForOwnerArgs>(GameViewMethods.nft_supply_for_owner, opts);
}

// nft_token query

export type INftTokenArgs = {
   token_id: string;
};

export type INftTokenResult = Token | null;

export function useNftTokenQuery(opts: Omit<NearQueryOptions<INftTokenResult, INftTokenArgs>, 'contract'>) {
    return useGameQueryRaw<INftTokenResult, INftTokenArgs>(GameViewMethods.nft_token, opts);
}

// nft_tokens query

export type INftTokensArgs = {
   from_index: U128 | null;
   limit: integer | null;
};

export type INftTokensResult = Token[];

export function useNftTokensQuery(opts: Omit<NearQueryOptions<INftTokensResult, INftTokensArgs>, 'contract'>) {
    return useGameQueryRaw<INftTokensResult, INftTokensArgs>(GameViewMethods.nft_tokens, opts);
}

// nft_tokens_for_owner query

export type INftTokensForOwnerArgs = {
   account_id: AccountId;
   from_index: U128 | null;
   limit: integer | null;
};

export type INftTokensForOwnerResult = Token[];

export function useNftTokensForOwnerQuery(opts: Omit<NearQueryOptions<INftTokensForOwnerResult, INftTokensForOwnerArgs>, 'contract'>) {
    return useGameQueryRaw<INftTokensForOwnerResult, INftTokensForOwnerArgs>(GameViewMethods.nft_tokens_for_owner, opts);
}

// nft_total_supply query

export type INftTotalSupplyArgs = {

};

export type INftTotalSupplyResult = U128;

export function useNftTotalSupplyQuery(opts: Omit<NearQueryOptions<INftTotalSupplyResult, INftTotalSupplyArgs>, 'contract'>) {
    return useGameQueryRaw<INftTotalSupplyResult, INftTotalSupplyArgs>(GameViewMethods.nft_total_supply, opts);
}

// nft_transfer mutation (payable)

export type INftTransferArgs = {
   receiver_id: AccountId;
   token_id: string;
   approval_id: integer | null;
   memo: string | null;
};

export type INftTransferResult = void;

export function useNftTransferMutation(opts: Omit<NearMutationOptions<INftTransferResult, INftTransferArgs>, 'contract'>) {
    return useGameMutationRaw<INftTransferResult, INftTransferArgs>(GameChangeMethods.nft_transfer, opts);
}

// nft_transfer_call mutation (payable)

export type INftTransferCallArgs = {
   receiver_id: AccountId;
   token_id: string;
   approval_id: integer | null;
   memo: string | null;
   msg: string;
};

export type INftTransferCallResult = PromiseOrValueBoolean;

export function useNftTransferCallMutation(opts: Omit<NearMutationOptions<INftTransferCallResult, INftTransferCallArgs>, 'contract'>) {
    return useGameMutationRaw<INftTransferCallResult, INftTransferCallArgs>(GameChangeMethods.nft_transfer_call, opts);
}

// nft_transfer_payout mutation (payable)

export type INftTransferPayoutArgs = {
   receiver_id: AccountId;
   token_id: string;
   approval_id: integer;
   balance: U128;
   max_len_payout: integer;
   memo: string | null;
};

export type INftTransferPayoutResult = Payout;

export function useNftTransferPayoutMutation(opts: Omit<NearMutationOptions<INftTransferPayoutResult, INftTransferPayoutArgs>, 'contract'>) {
    return useGameMutationRaw<INftTransferPayoutResult, INftTransferPayoutArgs>(GameChangeMethods.nft_transfer_payout, opts);
}

// set_is_paused mutation

export type ISetIsPausedArgs = {
   pause: boolean;
};

export type ISetIsPausedResult = boolean;

export function useSetIsPausedMutation(opts: Omit<NearMutationOptions<ISetIsPausedResult, ISetIsPausedArgs>, 'contract'>) {
    return useGameMutationRaw<ISetIsPausedResult, ISetIsPausedArgs>(GameChangeMethods.set_is_paused, opts);
}

// storage_balance_bounds query

export type IStorageBalanceBoundsArgs = {

};

export type IStorageBalanceBoundsResult = StorageBalanceBounds;

export function useStorageBalanceBoundsQuery(opts: Omit<NearQueryOptions<IStorageBalanceBoundsResult, IStorageBalanceBoundsArgs>, 'contract'>) {
    return useGameQueryRaw<IStorageBalanceBoundsResult, IStorageBalanceBoundsArgs>(GameViewMethods.storage_balance_bounds, opts);
}

// storage_balance_of query

export type IStorageBalanceOfArgs = {
   account_id: AccountId;
};

export type IStorageBalanceOfResult = StorageBalance | null;

export function useStorageBalanceOfQuery(opts: Omit<NearQueryOptions<IStorageBalanceOfResult, IStorageBalanceOfArgs>, 'contract'>) {
    return useGameQueryRaw<IStorageBalanceOfResult, IStorageBalanceOfArgs>(GameViewMethods.storage_balance_of, opts);
}

// storage_deposit mutation (payable)

export type IStorageDepositArgs = {
   account_id: AccountId | null;
   registration_only: boolean | null;
};

export type IStorageDepositResult = StorageBalance;

export function useStorageDepositMutation(opts: Omit<NearMutationOptions<IStorageDepositResult, IStorageDepositArgs>, 'contract'>) {
    return useGameMutationRaw<IStorageDepositResult, IStorageDepositArgs>(GameChangeMethods.storage_deposit, opts);
}

// storage_unregister mutation (payable)

export type IStorageUnregisterArgs = {
   force: boolean | null;
};

export type IStorageUnregisterResult = boolean;

export function useStorageUnregisterMutation(opts: Omit<NearMutationOptions<IStorageUnregisterResult, IStorageUnregisterArgs>, 'contract'>) {
    return useGameMutationRaw<IStorageUnregisterResult, IStorageUnregisterArgs>(GameChangeMethods.storage_unregister, opts);
}

// storage_withdraw mutation (payable)

export type IStorageWithdrawArgs = {
   amount: U128 | null;
};

export type IStorageWithdrawResult = StorageBalance;

export function useStorageWithdrawMutation(opts: Omit<NearMutationOptions<IStorageWithdrawResult, IStorageWithdrawArgs>, 'contract'>) {
    return useGameMutationRaw<IStorageWithdrawResult, IStorageWithdrawArgs>(GameChangeMethods.storage_withdraw, opts);
}

/**
 * Account identifier. This is the human readable utf8 string which is used internally to index accounts on the network and their respective state.
 *
 * Because these IDs have to be validated, they have to be converted from a string with [`FromStr`] or [`TryFrom`] a compatible type. To skip validation on initialization, [`AccountId::new_unchecked`] can be used.
 *
 * # Examples ``` use near_sdk::AccountId; use std::convert::{TryFrom, TryInto};
 *
 * // `FromStr` conversion let alice: AccountId = "alice.near".parse().unwrap(); assert!("invalid.".parse::<AccountId>().is_err());
 *
 * let alice_string = "alice".to_string();
 *
 * // From string with validation let alice = AccountId::try_from(alice_string.clone()).unwrap(); let alice: AccountId = alice_string.try_into().unwrap();
 *
 * // Initialize without validating let alice_unchecked = AccountId::new_unchecked("alice".to_string()); assert_eq!(alice, alice_unchecked); ```
 *
 * [`FromStr`]: std::str::FromStr
 */
export type AccountId = string;
export type Base64VecU8 = string;
export type RoomType = "Water" | "Food" | "Energy" | "Heal" | "AntiRad" | "Bedroom" | "Expedition";
export type U128 = string;
export type PromiseOrValueBoolean = boolean;
export type PromiseOrValueU128 = string;

export interface Definitions {
  AccountId?: AccountId;
  Base64VecU8?: Base64VecU8;
  FungibleTokenMetadata?: FungibleTokenMetadata;
  JsonNpc?: JsonNpc;
  JsonRoom?: JsonRoom;
  NFTContractMetadata?: NFTContractMetadata;
  Payout?: Payout;
  Player?: Player;
  Promise?: true;
  PromiseOrValueBoolean?: PromiseOrValueBoolean;
  PromiseOrValueU128?: PromiseOrValueU128;
  RoomType?: RoomType;
  Special?: Special;
  StorageBalance?: StorageBalance;
  StorageBalanceBounds?: StorageBalanceBounds;
  Token?: Token;
  TokenMetadata?: TokenMetadata;
  U128?: U128;
}
export interface FungibleTokenMetadata {
  decimals: number;
  icon?: string | null;
  name: string;
  reference?: string | null;
  reference_hash?: Base64VecU8 | null;
  spec: string;
  symbol: string;
}
export interface JsonNpc {
  hp: number;
  id: string;
  is_died: boolean;
  level: number;
  power: number;
  special: Special;
}
export interface Special {
  agility: number;
  charisma: number;
  endurance: number;
  intellect: number;
  luck: number;
  perception: number;
  strength: number;
}
export interface JsonRoom {
  claimed_at: number;
  effectiveness: number;
  enabled_time: number;
  id: string;
  level: number;
  npc_list: string[];
  power: number;
  refresh_at: number;
  room_type: RoomType;
  size: number;
}
/**
 * Metadata for the NFT contract itself.
 */
export interface NFTContractMetadata {
  base_uri?: string | null;
  icon?: string | null;
  name: string;
  reference?: string | null;
  reference_hash?: Base64VecU8 | null;
  spec: string;
  symbol: string;
}
export interface Payout {
  payout: {
    [k: string]: U128;
  };
}
export interface Player {
  anti_rad: number;
  anti_rad_max: number;
  energy: number;
  energy_max: number;
  food: number;
  food_max: number;
  heal: number;
  heal_max: number;
  power: number;
  process_at: number;
  room_limit: number;
  water: number;
  water_max: number;
}
export interface StorageBalance {
  available: U128;
  total: U128;
}
export interface StorageBalanceBounds {
  max?: U128 | null;
  min: U128;
}
/**
 * In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
 */
export interface Token {
  approved_account_ids?: {
    [k: string]: number;
  } | null;
  metadata?: TokenMetadata | null;
  owner_id: AccountId;
  token_id: string;
}
/**
 * Metadata on the individual token level.
 */
export interface TokenMetadata {
  copies?: number | null;
  description?: string | null;
  expires_at?: string | null;
  extra?: string | null;
  issued_at?: string | null;
  media?: string | null;
  media_hash?: Base64VecU8 | null;
  reference?: string | null;
  reference_hash?: Base64VecU8 | null;
  starts_at?: string | null;
  title?: string | null;
  updated_at?: string | null;
}

type integer = number;
// Code is generated by react-near

import { useNearQuery, useNearMutation, useNearEnv, NearEnvironment } from "react-near";
import { NearQueryOptions } from "react-near/hooks/query";
import { NearMutationOptions } from "react-near/hooks/mutation";

export const TOURNAMENT_CONTRACT_NAME_MAINNET = 'mfight-tournament.near';
export const TOURNAMENT_CONTRACT_NAME_TESTNET = 'mfight-tournament.testnet';

export enum TournamentViewMethods {
  tournament = 'tournament',
  tournament_free_places = 'tournament_free_places',
  tournament_is_whitelist_prize_owner = 'tournament_is_whitelist_prize_owner',
  tournament_member = 'tournament_member',
  tournament_metadata = 'tournament_metadata',
  tournament_nft_access = 'tournament_nft_access',
  tournament_players = 'tournament_players',
  tournament_prizes = 'tournament_prizes',
  tournaments = 'tournaments',
}

export enum TournamentChangeMethods {
  tournament_add_nft_access = 'tournament_add_nft_access',
  tournament_add_prize = 'tournament_add_prize', // payable
  tournament_add_whitelist_prize_owner = 'tournament_add_whitelist_prize_owner',
  tournament_create = 'tournament_create',
  tournament_end = 'tournament_end',
  tournament_execute_reward = 'tournament_execute_reward',
  tournament_join = 'tournament_join', // payable
  tournament_start = 'tournament_start',
}

export interface ITournamentContract {
   // view methods
   tournament(args: ITournamentArgs): ITournamentResult
   tournament_free_places(args: ITournamentFreePlacesArgs): ITournamentFreePlacesResult
   tournament_is_whitelist_prize_owner(args: ITournamentIsWhitelistPrizeOwnerArgs): ITournamentIsWhitelistPrizeOwnerResult
   tournament_member(args: ITournamentMemberArgs): ITournamentMemberResult
   tournament_metadata(args: ITournamentMetadataArgs): ITournamentMetadataResult
   tournament_nft_access(args: ITournamentNftAccessArgs): ITournamentNftAccessResult
   tournament_players(args: ITournamentPlayersArgs): ITournamentPlayersResult
   tournament_prizes(args: ITournamentPrizesArgs): ITournamentPrizesResult
   tournaments(args: ITournamentsArgs): ITournamentsResult
   // change methods
   tournament_add_nft_access(args: ITournamentAddNftAccessArgs): ITournamentAddNftAccessResult
   tournament_add_prize(args: ITournamentAddPrizeArgs): ITournamentAddPrizeResult
   tournament_add_whitelist_prize_owner(args: ITournamentAddWhitelistPrizeOwnerArgs): ITournamentAddWhitelistPrizeOwnerResult
   tournament_create(args: ITournamentCreateArgs): ITournamentCreateResult
   tournament_end(args: ITournamentEndArgs): ITournamentEndResult
   tournament_execute_reward(args: ITournamentExecuteRewardArgs): ITournamentExecuteRewardResult
   tournament_join(args: ITournamentJoinArgs): ITournamentJoinResult
   tournament_start(args: ITournamentStartArgs): ITournamentStartResult
}

export function useTournamentContractId() {
  const nearEnv = useNearEnv();

  return nearEnv.value === NearEnvironment.MainNet ? TOURNAMENT_CONTRACT_NAME_MAINNET : TOURNAMENT_CONTRACT_NAME_TESTNET;
}


export function useTournamentQueryRaw<Res = any, Req extends { [key: string]: any } = any>(
  methodName: TournamentViewMethods,
  opts: Omit<NearQueryOptions<Res, Req>, 'contract'> = {}
) {
  const contract = useTournamentContractId();
  return useNearQuery(methodName, { contract, ...opts });
}
export function useTournamentMutationRaw<Res = any, Req extends { [key: string]: any } = any>(
  methodName: TournamentChangeMethods,
  opts: Omit<NearMutationOptions<Res, Req>, 'contract'> = {}
) {
  const contract = useTournamentContractId();
  return useNearMutation(methodName, { contract, ...opts });
}

// tournament query

export type ITournamentArgs = {
   tournament_id: string;
   owner_id: AccountId;
};

export type ITournamentResult = JsonTournament | null;

export function useTournamentQuery(opts: Omit<NearQueryOptions<ITournamentResult, ITournamentArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentResult, ITournamentArgs>(TournamentViewMethods.tournament, opts);
}

// tournament_add_nft_access mutation

export type ITournamentAddNftAccessArgs = {
   tournament_id: string;
   token_ids: string[];
};

export type ITournamentAddNftAccessResult = void;

export function useTournamentAddNftAccessMutation(opts: Omit<NearMutationOptions<ITournamentAddNftAccessResult, ITournamentAddNftAccessArgs>, 'contract'>) {
    return useTournamentMutationRaw<ITournamentAddNftAccessResult, ITournamentAddNftAccessArgs>(TournamentChangeMethods.tournament_add_nft_access, opts);
}

// tournament_add_prize mutation (payable)

export type ITournamentAddPrizeArgs = {
   tournament_id: string;
   owner_id: AccountId;
   place_number: integer;
   prize_id: string;
};

export type ITournamentAddPrizeResult = void;

export function useTournamentAddPrizeMutation(opts: Omit<NearMutationOptions<ITournamentAddPrizeResult, ITournamentAddPrizeArgs>, 'contract'>) {
    return useTournamentMutationRaw<ITournamentAddPrizeResult, ITournamentAddPrizeArgs>(TournamentChangeMethods.tournament_add_prize, opts);
}

// tournament_add_whitelist_prize_owner mutation

export type ITournamentAddWhitelistPrizeOwnerArgs = {
   tournament_id: string;
   account_id: AccountId;
};

export type ITournamentAddWhitelistPrizeOwnerResult = void;

export function useTournamentAddWhitelistPrizeOwnerMutation(opts: Omit<NearMutationOptions<ITournamentAddWhitelistPrizeOwnerResult, ITournamentAddWhitelistPrizeOwnerArgs>, 'contract'>) {
    return useTournamentMutationRaw<ITournamentAddWhitelistPrizeOwnerResult, ITournamentAddWhitelistPrizeOwnerArgs>(TournamentChangeMethods.tournament_add_whitelist_prize_owner, opts);
}

// tournament_create mutation

export type ITournamentCreateArgs = {
   tournament_id: string;
   players_number: integer;
   price: U128 | null;
   name: string;
   media: string | null;
   summary: string | null;
   nft_access_contract: AccountId | null;
};

export type ITournamentCreateResult = void;

export function useTournamentCreateMutation(opts: Omit<NearMutationOptions<ITournamentCreateResult, ITournamentCreateArgs>, 'contract'>) {
    return useTournamentMutationRaw<ITournamentCreateResult, ITournamentCreateArgs>(TournamentChangeMethods.tournament_create, opts);
}

// tournament_end mutation

export type ITournamentEndArgs = {
   tournament_id: string;
};

export type ITournamentEndResult = void;

export function useTournamentEndMutation(opts: Omit<NearMutationOptions<ITournamentEndResult, ITournamentEndArgs>, 'contract'>) {
    return useTournamentMutationRaw<ITournamentEndResult, ITournamentEndArgs>(TournamentChangeMethods.tournament_end, opts);
}

// tournament_execute_reward mutation

export type ITournamentExecuteRewardArgs = {
   tournament_id: string;
   winner_place: integer;
   account_id: AccountId;
   prize_id: string;
};

export type ITournamentExecuteRewardResult = void;

export function useTournamentExecuteRewardMutation(opts: Omit<NearMutationOptions<ITournamentExecuteRewardResult, ITournamentExecuteRewardArgs>, 'contract'>) {
    return useTournamentMutationRaw<ITournamentExecuteRewardResult, ITournamentExecuteRewardArgs>(TournamentChangeMethods.tournament_execute_reward, opts);
}

// tournament_free_places query

export type ITournamentFreePlacesArgs = {
   tournament_id: string;
   owner_id: AccountId;
};

export type ITournamentFreePlacesResult = integer | null;

export function useTournamentFreePlacesQuery(opts: Omit<NearQueryOptions<ITournamentFreePlacesResult, ITournamentFreePlacesArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentFreePlacesResult, ITournamentFreePlacesArgs>(TournamentViewMethods.tournament_free_places, opts);
}

// tournament_is_whitelist_prize_owner query

export type ITournamentIsWhitelistPrizeOwnerArgs = {
   tournament_id: string;
   owner_id: AccountId;
   account_id: AccountId;
};

export type ITournamentIsWhitelistPrizeOwnerResult = boolean;

export function useTournamentIsWhitelistPrizeOwnerQuery(opts: Omit<NearQueryOptions<ITournamentIsWhitelistPrizeOwnerResult, ITournamentIsWhitelistPrizeOwnerArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentIsWhitelistPrizeOwnerResult, ITournamentIsWhitelistPrizeOwnerArgs>(TournamentViewMethods.tournament_is_whitelist_prize_owner, opts);
}

// tournament_join mutation (payable)

export type ITournamentJoinArgs = {
   tournament_id: string;
   owner_id: AccountId;
};

export type ITournamentJoinResult = void;

export function useTournamentJoinMutation(opts: Omit<NearMutationOptions<ITournamentJoinResult, ITournamentJoinArgs>, 'contract'>) {
    return useTournamentMutationRaw<ITournamentJoinResult, ITournamentJoinArgs>(TournamentChangeMethods.tournament_join, opts);
}

// tournament_member query

export type ITournamentMemberArgs = {
   tournament_id: string;
   owner_id: AccountId;
   account_id: AccountId;
};

export type ITournamentMemberResult = boolean;

export function useTournamentMemberQuery(opts: Omit<NearQueryOptions<ITournamentMemberResult, ITournamentMemberArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentMemberResult, ITournamentMemberArgs>(TournamentViewMethods.tournament_member, opts);
}

// tournament_metadata query

export type ITournamentMetadataArgs = {

};

export type ITournamentMetadataResult = TournamentFactoryMetadata;

export function useTournamentMetadataQuery(opts: Omit<NearQueryOptions<ITournamentMetadataResult, ITournamentMetadataArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentMetadataResult, ITournamentMetadataArgs>(TournamentViewMethods.tournament_metadata, opts);
}

// tournament_nft_access query

export type ITournamentNftAccessArgs = {
   tournament_id: string;
   owner_id: AccountId;
};

export type ITournamentNftAccessResult = string[];

export function useTournamentNftAccessQuery(opts: Omit<NearQueryOptions<ITournamentNftAccessResult, ITournamentNftAccessArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentNftAccessResult, ITournamentNftAccessArgs>(TournamentViewMethods.tournament_nft_access, opts);
}

// tournament_players query

export type ITournamentPlayersArgs = {
   tournament_id: string;
   owner_id: AccountId;
};

export type ITournamentPlayersResult = AccountId[];

export function useTournamentPlayersQuery(opts: Omit<NearQueryOptions<ITournamentPlayersResult, ITournamentPlayersArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentPlayersResult, ITournamentPlayersArgs>(TournamentViewMethods.tournament_players, opts);
}

// tournament_prizes query

export type ITournamentPrizesArgs = {
   tournament_id: string;
   owner_id: AccountId;
};

export type ITournamentPrizesResult = object;

export function useTournamentPrizesQuery(opts: Omit<NearQueryOptions<ITournamentPrizesResult, ITournamentPrizesArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentPrizesResult, ITournamentPrizesArgs>(TournamentViewMethods.tournament_prizes, opts);
}

// tournament_start mutation

export type ITournamentStartArgs = {
   tournament_id: string;
};

export type ITournamentStartResult = void;

export function useTournamentStartMutation(opts: Omit<NearMutationOptions<ITournamentStartResult, ITournamentStartArgs>, 'contract'>) {
    return useTournamentMutationRaw<ITournamentStartResult, ITournamentStartArgs>(TournamentChangeMethods.tournament_start, opts);
}

// tournaments query

export type ITournamentsArgs = {
   owner_id: AccountId;
   from_index: U128 | null;
   limit: integer | null;
};

export type ITournamentsResult = JsonTournament[];

export function useTournamentsQuery(opts: Omit<NearQueryOptions<ITournamentsResult, ITournamentsArgs>, 'contract'>) {
    return useTournamentQueryRaw<ITournamentsResult, ITournamentsArgs>(TournamentViewMethods.tournaments, opts);
}

/**
 * Account identifier. This is the human readable utf8 string which is used internally to index accounts on the network and their respective state.
 *
 * Because these IDs have to be validated, they have to be converted from a string with [`FromStr`] or [`TryFrom`] a compatible type. To skip validation on initialization, [`AccountId::new_unchecked`] can be used.
 *
 * # Examples ``` use near_sdk::AccountId; use std::convert::{TryFrom, TryInto};
 *
 * // `FromStr` conversion let alice: AccountId = "alice.near".parse().unwrap(); assert!("invalid.".parse::<AccountId>().is_err());
 *
 * let alice_string = "alice".to_string();
 *
 * // From string with validation let alice = AccountId::try_from(alice_string.clone()).unwrap(); let alice: AccountId = alice_string.try_into().unwrap();
 *
 * // Initialize without validating let alice_unchecked = AccountId::new_unchecked("alice".to_string()); assert_eq!(alice, alice_unchecked); ```
 *
 * [`FromStr`]: std::str::FromStr
 */
export type AccountId = string;
export type U128 = string;
export type PromiseOrValueBoolean = boolean;
export type PromiseOrValueU128 = string;
export type RewardPrize =
  | {
      Near: {
        amount: U128;
        owner_id?: AccountId | null;
      };
    }
  | {
      Ft: {
        amount: U128;
        ft_contract_id: AccountId;
        owner_id?: AccountId | null;
      };
    }
  | {
      Nft: {
        nft_contract_id: AccountId;
        owner_id?: AccountId | null;
        token_id: string;
      };
    };

export interface Definitions {
  AccountId?: AccountId;
  JsonTournament?: JsonTournament;
  PromiseOrValueBoolean?: PromiseOrValueBoolean;
  PromiseOrValueU128?: PromiseOrValueU128;
  RewardPrize?: RewardPrize;
  TournamentFactoryMetadata?: TournamentFactoryMetadata;
  TournamentMetadata?: TournamentMetadata;
  U128?: U128;
}
export interface JsonTournament {
  access_nft_contract?: AccountId | null;
  created_at: number;
  ended_at?: number | null;
  metadata: TournamentMetadata;
  owner_id: AccountId;
  players_current: number;
  players_total: number;
  price?: U128 | null;
  started_at?: number | null;
  tournament_id: string;
}
export interface TournamentMetadata {
  media?: string | null;
  name: string;
  summary?: string | null;
}
export interface TournamentFactoryMetadata {
  icon?: string | null;
  name: string;
}

type integer = number;